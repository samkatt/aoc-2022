(ns aoc-2022.day10
  (:require
   [clojure.java.io :as io]
   [clojure.string :as str]))

; input
(def demo-str "addx 15
addx -11
addx 6
addx -3
addx 5
addx -1
addx -8
addx 13
addx 4
noop
addx -1
addx 5
addx -1
addx 5
addx -1
addx 5
addx -1
addx 5
addx -1
addx -35
addx 1
addx 24
addx -19
addx 1
addx 16
addx -11
noop
noop
addx 21
addx -15
noop
noop
addx -3
addx 9
addx 1
addx -3
addx 8
addx 1
addx 5
noop
noop
noop
noop
noop
addx -36
noop
addx 1
addx 7
noop
noop
noop
addx 2
addx 6
noop
noop
noop
noop
noop
addx 1
noop
noop
addx 7
addx 1
noop
addx -13
addx 13
addx 7
noop
addx 1
addx -33
noop
noop
noop
addx 2
noop
noop
noop
addx 8
noop
addx -1
addx 2
addx 1
noop
addx 17
addx -9
addx 1
addx 1
addx -3
addx 11
noop
noop
addx 1
noop
addx 1
noop
noop
addx -13
addx -19
addx 1
addx 3
addx 26
addx -30
addx 12
addx -1
addx 3
addx 1
noop
noop
noop
addx -9
addx 18
addx 1
addx 2
noop
noop
addx 9
noop
noop
noop
addx -1
addx 2
addx -37
addx 1
addx 3
noop
addx 15
addx -21
addx 22
addx -6
addx 1
noop
addx 2
addx 1
noop
addx -10
noop
noop
addx 20
addx 1
addx 2
addx 2
addx -6
addx -11
noop
noop
noop")
(def input-str (slurp (io/reader (io/resource "input10.txt"))))

; input parsing
(defn line->step
  "Maps lines into [op arg] steps"
  [line] (cond
           (= "noop" line) [:noop 0]
           :else [:addx (Integer/parseInt (re-find #"-*\d+" line))]))
(line->step "addx -11") ; [:addx -11]
(line->step "addx 2") ; [:addx 2]
(line->step "noop") ; [:noop 0]

(defn str->program
  [str] (map line->step (str/split str #"\n")))
(take 3 (str->program demo-str)) ; ([:addx 15] [:addx -11] [:addx 6])

; handling steps
(defn apply-step
  "Given an cpu state and [op arg] produces next cpu states"
  [cpu-state [op arg]]
  (cond
    (= op :noop) [cpu-state]
    (= op :addx) [cpu-state (+ cpu-state arg)]))
(apply-step 1 [:noop 0]) ; [1]
(apply-step 1 [:addx -5]) ; [1 -4]

(defn apply-program
  "Runs a list of instructions"
  [init-state program]
  (reduce
   ; take in history of cpu-states and concatenate states generated by `apply-step`
   (fn [cpu-states step] (concat cpu-states (apply-step (last cpu-states) step)))
   init-state
   program))
(apply-program [1] [[:noop 0] [:noop 0] [:addx 10] [:noop 0]]) ; (1 1 1 1 11 11)

; getting output
(def signal-strenghts
  "Gets the signal strength during cpu states"
  (partial map-indexed (fn [i s] (* (inc i) s))))

(->> demo-str
     str->program
     (apply-program [1])
     signal-strenghts
     (drop 19)
     (take-nth 40)
     (apply +)) ; 13140

(->> input-str
     str->program
     (apply-program [1])
     signal-strenghts
     (drop 19)
     (take-nth 40)
     (apply +)) ; 12540

; Part 2
(defn is-visible?
  "Returns whether the sprite is visible"
  [cycle state] (let [idx (mod cycle 40)
                      diff (- idx state)]
                  (< (Math/abs diff) 2)))
(def bool->char {true \# false \.})

(->> demo-str
     str->program
     (apply-program [1])
     (map-indexed is-visible?)
     (map bool->char)
     (partition 40)
     (map (partial apply str)))

(->> input-str
     str->program
     (apply-program [1])
     (map-indexed is-visible?)
     (map bool->char)
     (partition 40)
     (map (partial apply str))
     (str/join "\n")
     print)
